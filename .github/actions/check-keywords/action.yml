name: Check Keywords

description: |
  Checks if git diff additions contain specific keywords or patterns.
  Returns simple boolean output.

inputs:
  patterns:
    description: 'Comma-separated list of patterns to search for'
    required: true
    type: string
  case-sensitive:
    description: 'Whether search should be case sensitive'
    required: false
    default: 'false'
    type: boolean
  base-ref:
    description: 'Base reference for diff calculation (default: origin/dev)'
    required: false
    default: 'origin/dev'
    type: string

outputs:
  found:
    description: 'Whether any patterns were found in additions'
    value: ${{ steps.check.outputs.found }}
  found_lines:
    description: 'JSON string of found lines with pattern and line content'
    value: ${{ steps.check.outputs.found_lines }}

runs:
  using: "composite"
  steps:
    - name: Check Keywords
      id: check
      shell: bash
      run: |
        PATTERNS="${{ inputs.patterns }}"
        CASE_SENSITIVE="${{ inputs.case-sensitive }}"
        BASE_REF="${{ inputs.base-ref }}"

        echo "Checking git diff additions for patterns: $PATTERNS"
        echo "Comparing HEAD against $BASE_REF"

        # Ensure we have the latest refs and the base ref exists
        git fetch --depth=1 origin
        if ! git rev-parse --verify "$BASE_REF" >/dev/null 2>&1; then
          echo "Error: Base reference '$BASE_REF' not found"
          exit 1
        fi

        # Build grep options
        GREP_OPTS=""
        [ "$CASE_SENSITIVE" = "false" ] && GREP_OPTS="-i"

        # Convert comma-separated patterns to array
        IFS=',' read -ra PATTERN_ARRAY <<< "$PATTERNS"

        # Get git diff additions and check for patterns
        FOUND=false
        declare -A PATTERN_LINES

        # Initialize pattern arrays
        for pattern in "${PATTERN_ARRAY[@]}"; do
          [ -n "$pattern" ] && PATTERN_LINES["$pattern"]=""
        done

        # Get all additions from git diff and check each line
        while IFS= read -r line; do
          # Skip empty lines and non-addition lines
          [ -z "$line" ] || [[ ! "$line" =~ ^\+ ]] && continue

          # Remove the "+" prefix and escape quotes for JSON
          CLEAN_LINE=$(echo "$line" | sed 's/^+//' | sed 's/"/\\"/g')

          # Check this line against all patterns
          for pattern in "${PATTERN_ARRAY[@]}"; do
            [ -z "$pattern" ] && continue

            if echo "$line" | grep $GREP_OPTS "$pattern" >/dev/null; then
              # Add line to this pattern's array
              if [ -n "${PATTERN_LINES[$pattern]}" ]; then
                PATTERN_LINES["$pattern"]="${PATTERN_LINES[$pattern]},"
              fi
              PATTERN_LINES["$pattern"]="${PATTERN_LINES[$pattern]}\"$CLEAN_LINE\""
              FOUND=true
            fi
          done
        done < <(git diff "$BASE_REF" HEAD | grep "^+" || true)

        # Build JSON output
        FOUND_LINES="{"
        FIRST=true
        for pattern in "${PATTERN_ARRAY[@]}"; do
          if [ -n "$pattern" ] && [ -n "${PATTERN_LINES[$pattern]}" ]; then
            [ "$FIRST" = "false" ] && FOUND_LINES="$FOUND_LINES,"
            FOUND_LINES="$FOUND_LINES\"$pattern\":[${PATTERN_LINES[$pattern]}]"
            FIRST=false
          fi
        done
        FOUND_LINES="$FOUND_LINES}"

        # Set outputs
        if [ "$FOUND" = "true" ]; then
          echo "Patterns found in code additions"
          echo "found=true" >> $GITHUB_OUTPUT
          echo "found_lines=$FOUND_LINES" >> $GITHUB_OUTPUT
        else
          echo "No patterns found in code additions"
          echo "found=false" >> $GITHUB_OUTPUT
          echo "found_lines={}" >> $GITHUB_OUTPUT
        fi
